# 1 对敏捷宣言的感受

## 1.1 个体和交互胜过过程和工具

人是获得成功的最为重要的因素。

## 1.2 可以工作的软件胜过面面俱到的文档

对于软件开发，需求是经常发生改变的，如果时刻保持文档和代码同步，需要花费大量的时间，性价比太低。

对于新人入职培训，最好的两个方向
- 源代码：代码是惟一没二义性的信息源；
- 团队交互：团队成员头脑中保存着整个软件开发过程变化的系统脉络图，可以了解到前因后果；

## 1.3 客户合作胜过合同谈判
项目需求是持续变化的，埋怨需求变动是无用的，最有效的方法只能是站在客户一侧真心的帮助客户达到目标，而不是去纠结这个功能改了多少次，或者去限制需求的变更。

成功的项目需要有序、频繁的客户反馈。

## 1.4 响应变化胜过遵循计划
由于项目需求变化的来源很多，一下子做详细的后期计划是不实际的。商务环境会变化，客户体验会改变需求等。

较好的做计划的策略是--为下两周做详细的计划，为下三个月做粗略的计划，再以后就做极为粗糙的计划。

# 2 设计原则
## 2.1 单一职责原则（SRP）
内聚性。

职责定义为“变化的原因”。如果你想到多个动机去改变一个类，那么这个类就具有多个职责。

只有佛自己应当负起公布玄妙秘密的职责。

## 2.2 开放封闭原则（OCP）
对于扩展是开放的，对于更改是封闭的。

OCP背后的主要机制是抽象和多态。

## 2.3 Liskov替换原则（LSP）
正是子类型的可替换性才使得使用基类类型的模块在无需修改的情况下就可以扩展。

LSP是使OCP成为可能的主要原则之一。

## 2.4 依赖倒置原则（DIP）
高层模块不应该依赖于低层模块。二者都应该依赖于抽象。

抽象不应该依赖于细节。细节应该依赖于抽象。

## 2.5 接口隔离原则（ISP）
不应该强迫客户依赖于它们不用的方法。

如果类接口不是内聚的，就表示该类具有胖类的接口。

胖类会导致它们的客户程序之间产生不正常的并且有害的耦合关系。

# 3 设计模式
# 3.1 command模式

仅由一个具有唯一方法的接口组成

# 3.2 active object模式
# 3.3 template method模式
# 3.4 strategy模式

不是将通用算法放到抽象基类中，而是一个叫ApplicationRunner的具体类

所以比template method更遵循DIP

# 3.5 facade模式
# 3.6 mediactor模式
# 3.7 singleton模式

使用私有构造函数，一个静态变量以及一个静态方法

# 3.8 monostate模式

把所有变量变成静态的

# 3.9 null object模式
# 3.10 factory模式
# 3.11 composite模式

# 3.12 observer模式

# 3.13 abstract server模式

switch和light之间由switchable接口，满足DIP和OCP

# 3.14 adapter模式

但其违反SRP，把light和switchable绑定了。用light adapter从switchable派生，并委托给light。

但是会付出实例化适配器、绑定和委托的时间空间代价

# 3.15 bridge模式

# 3.16 proxy模式

# 3.17 stairway to heaven模式

# 3.18 visitor模式

允许在不更改现有类层次结构的情况下向其中增加新方法

# 3.19 state模式

