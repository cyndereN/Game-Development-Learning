# 参考指南

1. 关注你的技艺。经验与直觉，好奇心，批判性，现实主义，做一个多面手。

2. 思考！思考你的工作。

3. 你有权选择。同时也要提供选择，不要找蹩脚借口

4. 不要容忍破窗户。看到糟糕的设计和代码时，修正他们

5. 做变化的催化剂。不能强迫人改变，而是展现未来

6. 记住大图景。

7. 使质量成为需求问题 。

8. 对知识资产做定期投资。学习成为习惯

9. 批判性地分析你读到和听到的东西。

10. 说什么和怎么说同样重要。

11. 不要重复自己DRY。每一项都要有单一、无歧义、权威的表示

12. 让复用变得更容易。

13. 消除不相关事物之间的影响。

14. 不存在最终决策，为变化做好计划。

15. Use tracer bullets to find the target

16. 为了学习而制做原型。

17. 靠近问题域编程。

18. 通过估算来避免意外。

19. 根据代码不断迭代进度表。

20. 将知识用纯文本保存。

21. 发挥shell命令的威力。

22. 游刃有余地使用编辑器。

23. 永远使用版本控制。回到过去

24. 去解决问题，而不是责备。

25. 不要恐慌。思考bug的原因

26. “select” 没出问题。bug一般在应用中

27. 不要假设，要证明。

28. 学习一门文本处理语言。

29. 编写能编写代码的代码。

30. 你不可能写出完美的软件。

31. 通过契约式进行设计。

32. 尽早崩溃。

33. 使用断言去预防不可能发生的事情。

34. 将异常用于异常的问题。

35. 有始有终。

36. 避免耦合。

37. 要配置，不要集成。

38. 将抽象放入代码，细节放入元数据。

39. 分析工作流程，以便改善并发性。

40. 用服务进行设计。根据服务——独立的、在良好定义、一直接口之后的并发对象——进行设计

41. 总是为并发进行设计。

42. 使视图与模型分离。

43. 用黑板协调工作。

44. 不要靠巧合编程。

45. 估算你算法的阶。

46. 测试你的估算。

47. 早重构，常重构。

48. 为测试而设计。

49. 测试你的软件，否则你的用户就得测试。

50. 不要使用你不理解的向导代码。

51. 不要搜集需求——挖掘他们。

52. 与用户一同工作，像用户一样思考。

53. 抽象比细节活得更长久。

54. 使用项目词汇表。

55. 不要在盒子外面思考——要找到盒子。遇到不可能解决的问题时，要确定真正的约束。问问自己：“它必须以这种方式完成吗？它真的必须完成吗？”

56. 等你准备好再开始。

57. 对有些事情“做”胜于“描述”

58. 不要做形式方法的奴隶。

59. 昂贵的工具不一定制作出更好的设计。

60. 围绕功能组织团队。

61. 不要使用手工流程。shell或批文件。

62. 早测试，常测试，自动化测试。

63. 通过全部测试编码才算完成。

64. 通过蓄意破坏测试你的测试。

65. 测试状态覆盖而不是代码覆盖。确定并测试重要的程序状态。只是测试代码行是不够的。

66. 一个bug只抓一次。此后自动测试应该对其检查。

67. 英语就是一种编程语言。像编写代码一样编写文档。

68. 把文档建在里面，不要栓在外面。

69. 温和地超出用户的期望。

70. 在你的作品上签名。

# 检查清单

71. 要学习的语言

72. WISDOM离合诗——了解听众

    What do you want them to learn?

    What is their interest in what you’ve got to say?

    How sophisticated are they?

    How much detail do they want?

    Whom do you want to own the information?

    How can you motivate them to listen to you?



73. 怎样维持正交性

- 设计对立、良好定义的组件
- 使你的代码保持解耦
- 避免使用全局数据
- 重构相似的函数

74. 应制作原型的事物

- 架构
- 已有系统中的新功能
- 外部数据的结构或内容
- 第三方工具或组件
- 性能问题
- 用户界面设计

75. 架构问题

- 责任是否得到了良好定义
- 协作是否得到了良好定义
- 耦合是否得以最小化
- 你能否确定潜在的重复
- 接口定义和各项约束是否可接受
- 模块是否能在需要时访问所需数据

76. 调试检查清单

- 正在报告的问题是底层bug的直接结果，还是只是症状？
- bug真的在编译器里？在os里？或者只是在你的代码里？
- 如果你的同事详细解释这个问题，你会说什么？
- 如果可疑代码通过了单元测试，测试是否足够完整？如果你用该数据运行单元测试，会发生什么？
- 造成这个bug的条件是否存在于系统的其他任何地方？

77. 函数的得墨忒耳法则

某个对象的方法应该只调用属于以下情形的方法：
- 它自身
- 传入得任何参数
- 他创建的对象
- 组件对象

78. 怎样深思熟虑的编程

- 总是意识到你在做什么
- 不要盲目地编程
- 按照计划行事
- 依靠可靠的事物
- 为你的假定建立文档
- 不单只要测试你的代码，还要测试你的假定
- 为你的工作划分优先级
- 不要做历史的奴隶

79. 何时进行重构

- 你发现了对DRY原则的违反
- 你发现事物可以更为正交
- 你的知识扩展了
- 需求演变了
- 你需要改善性能

80. 劈开戈尔迪斯结

在解决不可能的问题时，问问你自己：
- 有更容易的方法么
- 我是在解决正确的问题么
- 这件事情为什么是一个问题
- 是什么是他如此难以解决
- 它必须以这种方式完成吗
- 他真的必须完成吗

81. 测试的各个方面
- 单元测试
- 集成测试
- 验证和校验
- 资源耗尽、错误及恢复
- 性能测试
- 可用性测试
- 对测试自身进行测试


# 第1章 务实的哲学

## 1 我的源码被猫吃了

责任、坦诚

1. 赢得团队信任，小心维护，别破坏它

2. 承担责任，提供选择，别找借口。走向别人辩论之前先演练一遍，看看自己是否愚蠢。

## 2 软件的熵

软件规模带来的后增的重量

破窗效应：一扇破损的窗户，只要一段时间不修理，建筑中的居民就会潜移默化地产生一种被遗弃的感觉——当权者不关心这幢建筑的感觉。然后其他的窗户也开始损坏，居民开始乱丢废物，墙上开始出现涂鸦，建筑开始出现严重的结构性损坏。心理学家的研究表明，绝望是会传染的，就像狭窄空间中的流感病毒。无视一个明显损坏的东西，会强化这样一种观念：看来没有什么是能修好的，也没人在乎，一切都命中决定了。所有的负面情绪会在团队成员间蔓延，变成恶性循环。

1. 不要放任破窗，遇到问题（糟糕的设计、错误的决定、低劣的代码）不要回避，及早面对。不要让熵赢得胜利。
2. 不要只是因为一些东西非常危机，就去造成附带损害。破窗一扇都嫌太多。
3. “不要打破窗户”

## 3 石头汤与煮青蛙

展示前景，做推动变革的催化剂

1. 找出合理的请求，不断完善。一旦有成果产出，展示给人们看。引导推进，让大家能窥视未来。
2. 牢记全景，审视大局，而不要只专注个人在做的事情。

## 4 足够好的软件

用户参与权衡、知道何时止步

1. 完成用户需求，达到基本的性能、隐私和安全标准。
2. 与构想中的明天那个完美的软件相比，今天就还不错的软件通常更讨人喜欢。（人们不愿意等待、用户需求也有时效问题）
3. 不要让过度的修饰和精炼侵蚀掉一个完好的程序。

## 5 你的知识资产

知识与想法的交叉传授

1. 知识和经验是最重要的专业资产，但是也是一种时效资产。
2. 经营你的资产
    - 严肃的投资者定期投资——作为习惯。
        - 每年学习一门新语言
        - 每月读一本技术书
        - 读非技术书
        - 上课
        - 加入社群
        - 尝试不同的环境（开发环境）
        - 与时俱进
    - 多元化是长期成功的关键：知道的越多，价值越大。熟悉的技能越多，越能适应变化。。
    - 在保守的投资和高风险高回报的投资之间平衡他们的资产：不要把所有的技术鸡蛋都放在一个篮子里。
    - 设法低价高卖：在一项新兴技术变得流行之前就开始学习。
    - 周期性评估和平衡资产：不断尝试，温故而知新。

3. 学习的机会（与人交流、碎片化阅读）。把找到答案作为挑战。
4. 批评性思维：知识的精确性容易受到商业主义的影响




## 6 交流

说什么和怎么说一样重要

1. 多层次交流
    - 开会
    - 与终端用户合作
    - 编写代码
    - 编写文档
    - 写建议和备忘录
2. 知道你想要说什么
3. 了解听众：收集反馈，不要只是等待问题的出现，把问题问出来。
4. 选择时机
5. 选择风格
6. 让文档美观
7. 让听众参与
8. 做倾听者
9. 回复他人





# 第2章 注重实效的途径

## 7 重复的危害

作为程序员，我们做的就是收集、组织、维护以及治理知识。我们把知识文档化，写进规范；通过运行代码赋予知识以活力；在测试过程中，运用知识去知道应提供哪些检查。不幸的是，知识并不稳定。知识会改变——通常频率还很高。

1. 在一个系统中，每一处知识都必须单一、明确、权威地表达

2. 重复是怎样发生的：
- 强加的重复：开发者觉得无可选择——环境似乎要求重复
- 无意的重复：开发者没有意识到她们在重复信息
- 无奈性的重复：开发者偷懒
- 开发者之间的重复：同团队或不同团队的几个人重复了同样信息

## 8 正交性

1. 含义：在计算机科学中，象征着独立性和解耦性

2. 作用：消除不相关事物之间的影响（设计的组件自成一体：内聚）

3. 好处
    - 提高生产力
        - 减少开发和测试时间
        - 正交组件可组合使用，促进复用
        - 系统变得松散耦合，同时干的事情更多
    - 减少风险
        - 降低任何固有风险
        - 代码中病变的部分被隔离开
        - 更健壮，变更与修复产生的任何问题都仅局限在特定区域
        - 利于测试
        - 与外部组件结合时不会被束缚的太紧密

4. 项目团队责任正交

5. 设计
    - 当一个功能需求被变更后，受到影响的模块应该只有一个
    - 不要依赖那些你无法控制的东西

6. 工具箱和库：引入第三方工具包和程序库时，注意保持系统的正交性。

7. 编码：
    - 保持代码解耦
    - 避免全局数据（创建一个包含上下文的数据结构，并将结构传递出去）
    - 避免相似的函数（策略模式）



## 9 可撤销性

没有什么永远不变

1. 不设最终决定
2. 灵活的架构（除了代码，还要考虑体系结构、部署和供应商集成方面）
3. 放弃追逐时尚

## 10 曳光弹

1. 使用曳光弹找到目标
    - 用户能够更早的获得能工作的东西
    - 开发者构造了一个可以在其中工作的框架
    - 你有了一个集成平台
    - 你有演示的东西
    - 你对进度有更好的感觉
2. 曳光弹并不总能击中目标

## 11 原型与便笺

1. 需要做原型的东西
    - 架构
    - 已存在的系统中的新功能
    - 数据结构或外部数据的内容
    - 第三方工具或组件
    - 性能问题
    - 用户界面设计
2. 怎样使用原型
    - 正确性
    - 完整性
    - 健壮性
    - 格式
    - 使用高阶语言开山辟路（粘合剂、未来会丢弃原型）

3. 制作架构原型

    - 不必编写代码
    - 使用白板贴标签和索引卡
    - 尽量推迟思考细节

4. 不要把原型用于产品

## 12 领域语言

1. 靠近问题域编程
2. 权衡内部语言和外部语言

## 13 估算

1. 通过估算来避免意外
2. 多精确才够：挑选答案的单位来反映想要传达的精确性
3. 估算从何而来
    - 理解在问什么：掌握问题域的范围
    - 对系统建模：对于一个项目，可能是开发组织在开发期间需要的每个步骤，以及关于系统可能如何实现的粗略图景
    - 把模型分解成组件
    - 确定每个参数的值
    - 计算答案
    - 记录你的估算能力

4. 估算项目进度
    1. PERT（计划评审技术）：每个任务都有一个乐观的、一个最有可能的和一个悲观的估算
    2. 项目时间表（怎样吃掉大象？一次咬一口）
        - 检查需求
        - 分析风险
        - 设计、实现、集成
        - 和用户一起验证
        - 记录迭代的结束点，回到最初（检查需求），不断迭代进度表
    3. 放慢节奏：被要求做一个估算时，应该说“我等一下答复你”

# 第3章 基本工具

## 14 纯文本的威力

## 15 shell游戏

## 16 强力编辑

## 17 源码控制

## 18 调试

## 19 文本操纵

## 20 代码生成器

# 第4章 注重实效的偏执

## 21 按合约设计

## 22 死程序不说谎

## 23 断言式编程

## 24 何时使用异常

## 25 怎样配平资源

# 第5章 弯曲或折断